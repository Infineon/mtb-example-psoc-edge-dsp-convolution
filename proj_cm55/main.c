/*******************************************************************************
* File Name        : main.c
*
* Description      : This source file contains the main routine for CM55 CPU 
*                    to exercise DSP Convolution.
*
* Related Document : See README.md
*
********************************************************************************
* Copyright 2023-2025, Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
*
* This software, including source code, documentation and related
* materials ("Software") is owned by Cypress Semiconductor Corporation
* or one of its affiliates ("Cypress") and is protected by and subject to
* worldwide patent protection (United States and foreign),
* United States copyright laws and international treaty provisions.
* Therefore, you may use this Software only as provided in the license
* agreement accompanying the software package from which you
* obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software
* source code solely for use in connection with Cypress's
* integrated circuit products.  Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/

/*******************************************************************************
* Header Files
*******************************************************************************/
#include "arm_math.h"
#include "math.h"
#include "retarget_io_init.h"


/*******************************************************************************
* Macros
*******************************************************************************/
#define MAX_BLOCKSIZE        (128U)
#define SNR_THRESHOLD        (100U)
#define SOURCEA_LENGTH       (64U)
#define SOURCEB_LENGTH       (64U)
#define STRING_BUFFER_LENGTH (20U)
#define INPUTA_SIZE          (64U)
#define INPUTB_SIZE          (64U)
#define TEST_OUTPUT_SIZE     (127U)
#define RESET_VAL            (0.0)
#define NOT_A_NUMBER         (0x7FC00000U)
#define MULTIPLY_BY_TEN      (10U)
#define FFT_LENGTH           (64U)
#define FORWARD_TRANSFORM    (0U)
#define INVERSE_TRANSFORM    (1U)
#define ENABLE_BIT_REVERSAL  (1U)
#define ERROR_VAL            (0U)
#define OFFSET_VAL           (1U)


/*******************************************************************************
* Global Variables
*******************************************************************************/

/* Variables to hold input A and B */
float32_t Input_A[MAX_BLOCKSIZE];
float32_t Input_B[MAX_BLOCKSIZE];

/* Variable to hold the output of the operation */
float32_t AxB[MAX_BLOCKSIZE * 2];

/* Length of input A and B */
uint32_t src_a_length = SOURCEA_LENGTH;
uint32_t src_b_length = SOURCEB_LENGTH;

/* Length of convolution output */
uint32_t output_length;

/* Variable to hold output SNR */
float32_t snr;

char stringBuffer[STRING_BUFFER_LENGTH];

/*******************************************************************************
* Test input data for Floating-point convolution example based on a 
* 32-block size generated by MATLAB randn() function
*******************************************************************************/
float32_t testInputA_f32[INPUTA_SIZE] =
{
   -0.808920,   1.357369,   1.180861,  -0.504544,   1.762637,  -0.703285,
    1.696966,   0.620571,  -0.151093,  -0.100235,  -0.872382,  -0.403579,
   -0.860749,  -0.382648,  -1.052338,   0.128113,  -0.646269,   1.093377,
   -2.209198,   0.471706,   0.408901,   1.266242,   0.598252,   1.176827,
   -0.203421,   0.213596,  -0.851964,  -0.466958,   0.021841,  -0.698938,
   -0.604107,   0.461778,  -0.318219,   0.942520,   0.577585,   0.417619,
    0.614665,   0.563679,  -1.295073,  -0.764437,   0.952194,  -0.859222,
   -0.618554,  -2.268542,  -1.210592,   1.655853,  -2.627219,  -0.994249,
   -1.374704,   0.343799,   0.025619,   1.227481,  -0.708031,   0.069355,
   -1.845228,  -1.570886,   1.010668,  -1.802084,   1.630088,   1.286090,
   -0.161050,  -0.940794,   0.367961,   0.291907

};

float32_t testInputB_f32[INPUTB_SIZE] =
{
    0.933724,   0.046881,   1.316470,   0.438345,   0.332682,   2.094885,
    0.512081,   0.035546,   0.050894,  -2.320371,   0.168711,  -1.830493,
   -0.444834,  -1.003242,  -0.531494,  -1.365600,  -0.155420,  -0.757692,
   -0.431880,  -0.380021,   0.096243,  -0.695835,   0.558850,  -1.648962,
    0.020369,  -0.363630,   0.887146,   0.845503,  -0.252864,  -0.330397,
    1.269131,  -1.109295,  -1.027876,   0.135940,   0.116721,  -0.293399,
   -1.349799,   0.166078,  -0.802201,   0.369367,  -0.964568,  -2.266011,
    0.465178,   0.651222,  -0.325426,   0.320245,  -0.784178,  -0.579456,
    0.093374,   0.604778,  -0.048225,   0.376297,  -0.394412,   0.578182,
   -1.218141,  -1.387326,   0.692462,  -0.631297,   0.153137,  -0.638952,
    0.635474,  -0.970468,   1.334057,  -0.111370
};

const float testRefOutput_f32[TEST_OUTPUT_SIZE] =
{
   -0.818943,    1.229484,  -0.533664,    1.016604,   0.341875,  -1.963656,
    5.171476,    3.478033,   7.616361,    6.648384,   0.479069,   1.792012,
   -1.295591,   -7.447818,   0.315830,  -10.657445,  -2.483469,  -6.524236,
   -7.380591,   -3.739005,  -8.388957,    0.184147,  -1.554888,   3.786508,
   -1.684421,    5.400610,  -1.578126,    7.403361,   8.315999,   2.080267,
   11.077776,    2.749673,   7.138962,    2.748762,   0.660363,   0.981552,
    1.442275,    0.552721,  -2.576892,    4.703989,   0.989156,   8.759344,
   -0.564825,   -3.994680,   0.954710,   -5.014144,   6.592329,   1.599488,
  -13.979146,   -0.391891,  -4.453369,   -2.311242,  -2.948764,   1.761415,
   -0.138322,   10.433007,  -2.309103,    4.297153,   8.535523,   3.209462,
    8.695819,    5.569919,   2.514304,    5.582029,   2.060199,   0.642280,
    7.024616,    1.686615,  -6.481756,    1.343084,  -3.526451,   1.099073,
   -2.965764,   -0.173723,  -4.111484,    6.528384,  -6.965658,   1.726291,
    1.535172,   11.023435,   2.338401,   -4.690188,   1.298210,   3.943885,
    8.407885,    5.168365,   0.684131,    1.559181,   1.859998,   2.852417,
    8.574070,   -6.369078,   6.023458,   11.837963,  -6.027632,   4.469678,
   -6.799093,   -2.674048,   6.250367,   -6.809971,  -3.459360,   9.112410,
   -2.711621,   -1.336678,   1.564249,   -1.564297,  -1.296760,   8.904013,
   -3.230109,    6.878013,  -7.819823,    3.369909,  -1.657410,  -2.007358,
   -4.112825,    1.370685,  -3.420525,   -6.276605,   3.244873,  -3.352638,
    1.545372,    0.902211,   0.197489,   -1.408732,   0.523390,   0.348440, 0
};

/*******************************************************************************
* Function Definitions
*******************************************************************************/
/*******************************************************************************
* Function Name: snr_f32
********************************************************************************
* Summary:
*  The function calculates signal to noise ratio (SNR) for the reference output
*  and test output.
*
* Parameters:
*  pRef        :Pointer to the reference buffer
*  pTest       :Pointer to the test buffer 
*  buffSize    :Total number of samples
*
* Return:
*  float
*
*******************************************************************************/
float snr_f32(float *pRef, float *pTest, uint32_t buffSize)
{
    float energy_signal = RESET_VAL;
    float energy_error = RESET_VAL;
    float SNR;
    int temp;
    int *test;
    uint32_t i;
    float result;

    for (i = 0; i < buffSize; i++)
    {
        /* Checking for a NAN value in pRef array */
        test = (int *)(&pRef[i]);
        temp = *test;

        if (NOT_A_NUMBER != temp)
        {
            /* Checking for a NAN value in pTest array */
            test = (int *)(&pTest[i]);
            temp = *test;

            if (NOT_A_NUMBER != temp )
            {
                energy_signal += pRef[i] * pRef[i];
                energy_error  += (pRef[i] - pTest[i]) * (pRef[i] - pTest[i]);
            }
            else
            {
                result=ERROR_VAL;
            }
        }
        else
        {
            result = ERROR_VAL;
        }
    }

    /* Checking for a NAN value in energy_error */
    test = (int *)(&energy_error);
    temp = *test;

    if (NOT_A_NUMBER != temp )
    {
        SNR = MULTIPLY_BY_TEN * log10 (energy_signal / energy_error);
        result = SNR;
    }
    else
    {
        result = ERROR_VAL;
    }

    return (result);
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
*  This is the main function for CM55 CPU. It...
*    1. Initializes the input buffers with all zeros.
*    2. Copies the input buffers to fft buffers.
*    3. Initializes and performs CFFT.
*    4. Does complex multiplication of two buffers in frequency domain.
*    5. Initializes and performs ICFFT.
*    6. Calculates SNR and compares it with threshold.
*
* Parameters:
*  void
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    /* Result variable*/
    cy_rslt_t result;

    /* Variable to hold the status of the operation */
    arm_status status;

    /* CFFT Structure instance */
    arm_cfft_radix4_instance_f32 cfft_instance;

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (CY_RSLT_SUCCESS != result)
    {
        handle_app_error();
    }

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io middleware */
    init_retarget_io();

    /* Clear UART Terminal Window*/
    printf("\x1b[2J\x1b[;H");

    printf("************************ PSOC Edge MCU: DSP Convolution "
    "************************\r\n\n");

    /* CFFT Structure instance pointer */
    arm_cfft_radix4_instance_f32 *cfft_instance_ptr =
    (arm_cfft_radix4_instance_f32*) &cfft_instance;

    /* output length of convolution */
    output_length = src_a_length + src_b_length - OFFSET_VAL;
    printf("Performing convolution using M55 Helium extension..\r\n\n");

    /* Initialise the fft input buffers with all zeros */
    arm_fill_f32(RESET_VAL, Input_A, MAX_BLOCKSIZE);
    arm_fill_f32(RESET_VAL, Input_B, MAX_BLOCKSIZE);

    /* Copy the input values to the fft input buffers */
    arm_copy_f32(testInputA_f32, Input_A, MAX_BLOCKSIZE/2);
    arm_copy_f32(testInputB_f32, Input_B, MAX_BLOCKSIZE/2);

    /* Initialize the CFFT function to compute 64 point fft */
    status = arm_cfft_radix4_init_f32(cfft_instance_ptr, FFT_LENGTH,
    FORWARD_TRANSFORM, ENABLE_BIT_REVERSAL);

    /* Transform input a[n] from time domain to frequency domain A[k] */
    arm_cfft_radix4_f32(cfft_instance_ptr, Input_A);

    /* Transform input b[n] from time domain to frequency domain B[k] */
    arm_cfft_radix4_f32(cfft_instance_ptr, Input_B);

    /* Complex Multiplication of the two input buffers in frequency domain */
    arm_cmplx_mult_cmplx_f32(Input_A, Input_B, AxB, MAX_BLOCKSIZE/2);

    /* Initialize the CIFFT function to compute 64 point ifft */
    status = arm_cfft_radix4_init_f32(cfft_instance_ptr, FFT_LENGTH,
    INVERSE_TRANSFORM, ENABLE_BIT_REVERSAL);

    /* Transform the multiplication output from frequency domain to
     * time domain, that gives the convolved output. */
    arm_cfft_radix4_f32(cfft_instance_ptr, AxB);

    printf("Calculating SNR (signal-to-noise ratio) between convolved signal\n\r"
    "and reference signal..\r\n\n");

    /* SNR Calculation */
    snr = snr_f32((float32_t *)testRefOutput_f32, AxB, src_a_length +
                  src_b_length - OFFSET_VAL);
    printf("SNR Value : %f\r\n\n",snr);

    /* Compare the SNR with threshold to test whether the
     * computed output is matched with the reference output values.
     */
    status = (SNR_THRESHOLD >= snr) ? ARM_MATH_TEST_FAILURE : ARM_MATH_SUCCESS;

    if (ARM_MATH_SUCCESS != status)
    {
      printf("SNR value is less than threshold value (100): "
      "CONVOLUTION FAILED\r\n\n");
    }
    else
    {
      printf("SNR value is greater than threshold value (100): "
      "CONVOLUTION SUCCESS\r\n\n");
    }

    for (;;)
    {
    }
}


/* [] END OF FILE */